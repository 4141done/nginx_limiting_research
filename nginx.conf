load_module modules/ngx_http_js_module.so;

events {}

http {
    # We don't want every query param combination to act as a key, so
    # make sure we're just dealing with the uri sans steps as the unit of limit
    js_set $limitable_uri script.limitableUri;

  #
  # Import NJS code
  js_import script from script.mjs;
  include /etc/nginx/mime.types;

  # KeyValue store for global counting
  keyval_zone zone=global_counter:1m timeout=5m sync;
  keyval account_id:$http_x_account_id $global_counter zone=global_counter;
  
  # KeyValue store for per-user counting
  keyval_zone zone=user_level_counter:1m timeout=5m sync;
  keyval account_id:$http_account_id:user_id:$http_user_id $user_level_counter zone=user_level_counter;

  #
  # Define Key-Value Store for counter node selection
  keyval_zone zone=countnode:1m timeout=1m sync;
  keyval $http_x_forwarded_for:$request_method:$limitable_uri $countnode zone=countnode;

  #
  # Use Docker's built-in DNS server for service discovery
  resolver 127.0.0.11 valid=60s status_zone=docker_dns;

  upstream backends {

    zone backends 64k;
    server pool resolve;
  }

  #
  # Inbound traffic arrives on port 4000
  server {
  
    # Set account level and user level quotas
    set $global_request_quota 10;
    set $user_request_quota 5;

    listen 4000;
    status_zone http_traffic;
    
    location / {
      try_files $uri @rate_limit_check;
    }
        
    location @rate_limit_check {
      js_content script.staticWindowRateLimiter;
    }
    
    location /do_proxy {
        internal;
        proxy_pass http://backends;
    }

    # NGINX Plus API for updating key-value store, and providing metrics for dashboard
    location /api {
      api write=on;
    }

    #
    # NGINX Plus Realtime monitoring dashboard
    location /dashboard.html {

      root /usr/share/nginx/html;
    }
  }
}

#
# Zone Synchronization happens over port 9000
stream {

  resolver 127.0.0.11 valid=10s;

  server {
    listen 9000;
    zone_sync;
    zone_sync_server lb:9000 resolve;
  }
}

